---
layout:     post                    # 使用的布局（不需要改）
title:      c++：杂项，技巧和陷阱             # 标题 
subtitle:   Miscellaneous, Tips and Traps #副标题
date:       2017-12-01              # 时间
author:     whillys                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - c++
    - Miscellaneous, Tips and Traps
---

### 1. 异常处理

c++通过关键字throw,try,catch和头文件`<exception>,<stdexcept>`将异常处理构建到了语言中。

在创建类时，通常通过构造函数和setter函数来对输入数据进行有效性检查。在校验输入时，对异常的数据要么通过调用exit()、abort()函数来终止程序，要么设置默认值，一种更好的做法是抛出一个异常给调用者，让调用者来决定如何处理这个异常。

#### 1.1 throw,try和catch

假设我们有一个PositiveInteger类，他有一个数据成员用来存放一个正数。

PositiveIntege.h

    #ifnef POSITIVEINTEGER_H
    #define POSITIVEINTEGER_H
    
    class PositiveInteger
    {
    private:
    	int value;
    public:
    	PositiveInteger(int value = 1);
    	void setValue(int value);	
    	int getValue()const;
    };
    
    #endif

PositiveInteger.cpp

    PositiveInteger::PositiveInteger(int value)
    {
    	setValue(value);	//构造函数中调用setter函数
    }
    
    //在setter函数中对输入参数进行校验
    void PositiveInteger::setValue(int value)
    {
    	if (value > 0)
    		this->value = value;
    	else	
    		throw invalid_argument("value shall be more than 0");	//需要头文件<stdexcept>
    }
    
    int PositiveInteger::getValue()const
    {
    	return value;
    }

**程序说明**：

在构造函数中调用了setter函数，setter函数中进行了参数校验。

在setValue()函数中，如果输入不合法，我们没有打印错误信息，也没有调用exit()/abort()函数来终止程序，而是抛出一个invalid_argument异常（带有合适的提示信息），invalid_argument是头文件`<stdexcept>`中系统定义的一个异常类。

TestPositiveInteger.cpp

    /* Test Driver for the PositiveInteger class (TestPositiveInteger.cpp) */
    #include <iostream>
    #include <stdexcept>  // Needed for exception handling
    #include "PositiveInteger.h"
    using namespace std;
     
    int main() {
       // Valid input
       PositiveInteger i1(8);
       cout << i1.getValue() << endl;
     
       // Invalid input without try-catch
    // PositiveInteger i2(-8);  // Program terminate abruptly
     
       // Graceful handling of exception with try-catch
       try {
      cout << "begin try 1..." << endl;
      PositiveInteger i3(-8);
     // Exception thrown.
     // Skip the remaining statements in try and jump to catch.
      cout << i3.getValue() << endl;
      cout << "end try 1..." << endl;
     // Continue to the next statement after try-catch, if there is no exception
       } catch (invalid_argument & ex) {  // need <stdexcept>
      cout << "Exception: " << ex.what() << endl;
     // Continue to the next statement after try-catch
       }
       cout << "after try-catch 1..." << endl;
     
       // Graceful handling of exception with try-catch
       try {
      cout << "begin try 2..." << endl;
      PositiveInteger i4(8); // no exception thrown
      cout << i4.getValue() << endl;
      cout << "end try 2..." << endl;
     // Continue to the next statement after try-catch, if there is no exception
       } catch (invalid_argument & ex) {  // need <stdexcept>
      cout << "Exception: " << ex.what() << endl;
     // Continue to the next statement after try-catch
       }
       cout << "after try-catch 2..." << endl;
    }

**程序说明**：

没有try-catch语句，当遇到throw语句时，程序会非正常终止。
使用try-catch，当遇到throw语句时，程序执行会跳过try语句的剩余部分，然后跳到catch语句；然后继续执行try-catch后面的语句，此事，程序不会异常终止。
如果没有遇到异常，程序会执行完try语句，跳过catch语句，然后继续catch后面的语句。
catch 带有一个指向异常类引用的参数，异常类定义在头文件`<exception>或<stdexcept>`中。
异常类有一个成员函数what()，它会打印异常信息。
程序中可以有多个catch语句，每个catch接收一种异常类型。如果一个异常抛出，多个catch语句按顺序去匹配。
如果抛出的异常没有catch与其匹配，程序会返回到调用者，然后重复异常处理。

#### 1.2 类exception和其子类

![](https://github.com/whillys/whillys.github.io/blob/master/img/miscs_exception.png)

根类exception定义在头文件<exception>中，它包含一个称为what()的成员函数，返回异常信息。 具体可以查看：

[std::exception](http://www.cplusplus.com/reference/exception/exception/)

    virtual const char* what() const throw();
       // what() is a virtual function, can be overridden by subclasses
       // It returns a C-string.

一些常用的子类定义在头文件<stdexcept>中：

1、 logic_error：指出程序中的逻辑错误，例如invalid_argument(传递给函数的参数不合法)，out_of_range(例如，下标越界，溢出)，length_error(长度大于最大允许长度)，等待。

    class logic_error : public exception {
    public:
      explicit logic_error (const string & what_message);
    };

2、runtime_error：指出程序运行过程中遇到的错误，例如range_error, overflow_error, under_flow_error。

3、bad_exception：意外的异常

#### 1.3 创建自己的exception子类

你可以创建自己的异常类，从exception或其子类（例如，logic_error or runtime_error）继承，例如：

MyException.h

    #ifndef MYEXCEPTION_H
    #define MYEXCEPTION_H
    
    #include<stdexcept>
    
    class MyException: public std::logic_error
    {
    public:
    MyException(): std::logic_error("my custome error") {}
    };
    
    #endif

**程序说明**：

1. 自定义的异常类应该是exception或其子类的子类，例如，MyException从logic_error继承。
1. 为构造函数提供一个what-message。

TestMyException.cpp

    #include<iostream>
    #include"MyException.h"
    
    using namespace std;
    
    void fun()
    {
    throw MyException();
    }
    
    int main()
    {
    try
    {
    fun();
    }
    catch(MyException & ex)
    {
    cout << ex.what() << endl;
    }
    
    return 0;
    }

### 2. 存储期限，作用域和链接性

回想一下，一个变量有名字，类型，存放特定类型的值，它也有其他的属性，例如，存储持久性，作用域，链接性，这些特性是隐式设置的，当然也可以通过存储类说明符指定，例如auto,register,static,extern,mutable和thread_local（c++11),或者CV限定符：const和volatile。

**存储持久性**：Automatic, Static and Dynamic

1、自动存储持久性：函数中定义的变量包括函数参数，语句块变量具有自动存储持久性。它们在程序运行到包含它们定义的地方时为其分配存储空间，程序离开它们所在的代码块时释放它们的存储空间。 它们的创建和删除是自动进行的。

2、静态存储持久性：定义在函数外部，或者用static定义在函数内部的变量具有静态存储持久性。static意味着：a:变量在程序开始运行是创建，在程序退出时删除，b:在程序整个执行过程中，保留其内存中的内容。

3、动态存储持久性：动态存储持久性通过程序显式的来管理，存储空间在堆上，通过new关键字来分配，delete类释放。

编译器会开辟三块内存区域分别用于自动变量，静态变量和动态变量。

**作用域**：Local or Global

变量的作用域决定了程序中哪些部分可以访问它，也就是可见性。 有的变量在整个程序中都可见（具有文件作用域或全局作用域），有的变量只能被程序中某些部分访问（块作用域or本地作用域），例如，定义在一个函数中的自动变量只在定义它的函数中可见，在函数外面不可见。

有两种作用域：

1. 本地作用域（块作用域）：只在代码块中可见。
1. 全局作用域（文件作用域）：在整个源代码文件中都可见。

**链接性**：Internal or External

一个c++应用程序可能由多个源代码文件组成，变量的链接性决定了变量是否能被其他文件访问，具有外部链接性的变量能够被其他文件访问，具有内部链接性的变量在能够在定义它的文件中被访问。也就是说，外部链接特性把变量的文件作用域扩展到了其他文件。

总的来说，加上链接性，有三种作用域和链接性的组合：

1. 本地作用域（块作用域）无链接性。
1. 文件作用域（全局作用域）外部链接性。
1. 文件作用域（全局作用域）内部链接性。











